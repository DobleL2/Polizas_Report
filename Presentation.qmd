---
title: "Reportes Polizas"
date: "06-13-24"
institute: "Escuela Politécnica Nacional"
author: "Luis Lapo, Mathew Cisneros"
format: 
  revealjs:
    transition: zoom
    background-transition: fade
    scrollable: true
    navigation-mode: vertical
editor: visual
title-slide-attributes:
    data-background-image: "images/background2.png"
    
server: shiny
---

## Entendimiento de los datos {.smaller background-image="images/background2.png"}

::: panel-tabset
### Primer Acercamiento

```{r}
# Cargar las bibliotecas necesarias
library(readxl)  # Para leer archivos Excel
library(dplyr)   # Para manipulación de datos
library(ggplot2) # Para visualización de datos
library(tidyr)   # Para manipular la estructura de los datos
library(knitr) 

# Leer el archivo de Excel
path_file = "polizas.xlsx"
datos <- read_excel(path_file)

# Generar un data.frame en donde se indica el tipo de dato y la cantidad de valores no nulos por columna
df_tipos <- data.frame(
  Tipo_Dato = sapply(datos, class),
  Valores_no_nulos = sapply(datos, function(x) sum(!is.na(x)))
)
```

::: columns
::: {.column width="33%" style="font-size: 0.7em;width:43%;text-align: justify;"}
### Primer acercamiento

El objetivo sería definir el tipo de variables ya sean cuantitativas o cualitativas de cada columna del dataset. En primer lugar determinamos el tipo de dato que se tiene en cada columna y la cantidad de valores no nulos.
:::

::: {.column width="5%"}
:::

::: {.column width="42%" style="font-size: 0.6em;width:45%"}
```{r}
knitr::kable(df_tipos[,c("Tipo_Dato",	"Valores_no_nulos")])
```
:::
:::

### Datos {style="font-size: 0.7em"}

```{r}
knitr::kable(head(datos))
```
:::

## Lectura de los datos en r {.smaller background-image="images/background2.png"}

``` {.r code-line-numbers="2-6|9-10|13-16"}
# Cargar las bibliotecas necesarias
library(readxl)  # Para leer archivos Excel
library(dplyr)   # Para manipulación de datos
library(ggplot2) # Para visualización de datos
library(tidyr)   # Para manipular la estructura de los datos
library(knitr)   # Para generar reportes dinámicos

# Leer el archivo de Excel
path_file = "polizas.xlsx"
datos <- read_excel(path_file)

# Generar un data.frame en donde se indica el tipo de dato y la cantidad de valores no nulos por columna
df_tipos <- data.frame(
  Tipo_Dato = sapply(datos, class),
  Valores_no_nulos = sapply(datos, function(x) sum(!is.na(x)))
)
```

## Introduccion al dataset {.smaller background-image="images/background2.png"}

::: panel-tabset
### Introducción {style="text-align: justify;"}

Las pólizas de seguro son esenciales para proteger a individuos y empresas contra riesgos financieros imprevistos, ofreciendo estabilidad económica. Analizar estos datos ayuda a las aseguradoras a comprender mejor los riesgos y adaptar sus productos a las necesidades específicas de los clientes.

### ¿Que son las polizas de seguro? {style="text-align: justify;"}

Las pólizas de seguro son contratos entre una entidad aseguradora y una persona o empresa, en los cuales la aseguradora se compromete a compensar al asegurado por pérdidas específicas a cambio de una prima periódica. Estos contratos proporcionan protección financiera cubriendo diversos riesgos, como accidentes, enfermedades, daños a la propiedad, o responsabilidad legal.
:::

## Análisis de los valores atípicos {.smaller background-image="images/background2.png"}

```{r}
datos_modificados_cuartiles <- function(datos, nombre_columna, cuartil_inferior, cuartil_superior) {
  ci <- cuartil_inferior / 100
  cs <- cuartil_superior / 100
  
  # Acceder dinámicamente a la columna usando [[ ]]
  t <- datos[[nombre_columna]]
  
  # Calcular cuartiles y IQR basado en estos cuartiles personalizados
  Qinf <- quantile(t, ci, na.rm = TRUE)
  Qsup <- quantile(t, cs, na.rm = TRUE)
  IQR <- Qsup - Qinf
  
  # Determinar y corregir valores atípicos
  lower_bound <- Qinf - 1.5 * IQR
  upper_bound <- Qsup + 1.5 * IQR
  t <- ifelse(t < lower_bound, lower_bound, ifelse(t > upper_bound, upper_bound, t))
  
  # Actualizar la columna en el dataframe original
  datos[[nombre_columna]] <- t
  
  return(datos)
}



diagrama_caja_bigotes<- function(datos, nombre_columna, cuartil_inferior, cuartil_superior){
  # Convertir porcentajes a decimales
  ci <- cuartil_inferior / 100
  cs <- cuartil_superior / 100
  
  # Extraer la columna de interés
  columna_datos <- datos[[nombre_columna]]
  
  # Calcular los cuártiles personalizados
  Qinf <- quantile(columna_datos, ci, na.rm = TRUE)
  Qsup <- quantile(columna_datos, cs, na.rm = TRUE)
  
  # Crear el boxplot
  p <- ggplot(datos, aes_string(x = "1", y = nombre_columna)) +
    geom_boxplot() +
    geom_hline(yintercept = c(Qinf, Qsup), color = "red", linetype = "dashed") +
    labs(title = paste("Boxplot con Cuártiles Personalizados: ", nombre_columna),
         x = "",
         y = nombre_columna) +
    theme_minimal() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Imprimir el gráfico
  print(p)
}
```

```{r}
fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput("slider2", label = h4("Rango cuantiles"), min = 0, 
                  max = 100, value = c(25, 75))
    ),
    mainPanel(
      textOutput("sliderValues"),
      plotOutput("viewGrafico"),
      plotOutput("viewGrafico2")
    )
  )
)


```

```{r}
#| context: server
library(readxl)
library(ggplot2)
path_file = "polizas.xlsx"
datos <- read_excel(path_file)

output$sliderValues <- renderText({
    paste("Rango Seleccionado:", input$slider2[1], "-", input$slider2[2])
  })

datos_modificados_cuartiles <- function(datos, nombre_columna, cuartil_inferior, cuartil_superior) {
  ci <- cuartil_inferior / 100
  cs <- cuartil_superior / 100
  
  # Acceder dinámicamente a la columna usando [[ ]]
  t <- datos[[nombre_columna]]
  
  # Calcular cuartiles y IQR basado en estos cuartiles personalizados
  Qinf <- quantile(t, ci, na.rm = TRUE)
  Qsup <- quantile(t, cs, na.rm = TRUE)
  IQR <- Qsup - Qinf
  
  # Determinar y corregir valores atípicos
  lower_bound <- Qinf - 1.5 * IQR
  upper_bound <- Qsup + 1.5 * IQR
  t <- ifelse(t < lower_bound, lower_bound, ifelse(t > upper_bound, upper_bound, t))
  
  # Actualizar la columna en el dataframe original
  datos[[nombre_columna]] <- t
  
  return(datos)
}

inferior <- reactive({
  input$slider2[1]
})

superior <- reactive({
  input$slider2[2]
})

# Make the data reactive by depending on 'inferior' and 'superior'
d1 <- reactive({
  datos_modificados_cuartiles(datos, 'prima_emitida', inferior(), superior())
})

d2 <- reactive({
  datos_modificados_cuartiles(d1(), 'prima_anual', inferior(), superior())
})

data <- reactive({
  datos_modificados_cuartiles(d2(), 'suma_aseg', inferior(), superior())
})

diagrama_caja_bigotes<- function(datos, nombre_columna, cuartil_inferior, cuartil_superior){
  # Convertir porcentajes a decimales
  ci <- cuartil_inferior / 100
  cs <- cuartil_superior / 100
  
  # Extraer la columna de interés
  columna_datos <- datos[[nombre_columna]]
  
  # Calcular los cuártiles personalizados
  Qinf <- quantile(columna_datos, ci, na.rm = TRUE)
  Qsup <- quantile(columna_datos, cs, na.rm = TRUE)
  
  # Crear el boxplot
  p <- ggplot(datos, aes_string(x = "1", y = nombre_columna)) +
      geom_boxplot() +
      geom_hline(yintercept = c(Qinf, Qsup), color = "red", linetype = "dashed") +
      labs(title = paste("Boxplot con Cuártiles Personalizados: ", nombre_columna),
           x = "",
           y = nombre_columna) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(),
            panel.background = element_rect(fill = "transparent"), # Hace el fondo transparente
            plot.background = element_rect(fill = "transparent", color = NA)) # Hace el fondo de la gráfica transparente
  
  # Imprimir el gráfico
  return(p)
}

grafico <- reactive({
  diagrama_caja_bigotes(datos, 'prima_emitida', inferior(), superior())
})

grafico2 <- reactive({
  diagrama_caja_bigotes(data(), 'prima_emitida', inferior(), superior())
})

  # Render table output correctly
output$viewTable <- renderTable(
  head(data()), width = "100%"
)

output$viewGrafico <- renderPlot(
  grafico()
)

output$viewGrafico2 <- renderPlot({
  grafico2()
})
```

## Relacion sucursal y ramo comercial {.smaller background-image="images/background2.png"}

::: panel-tabset
### Tabla de contingencia {.smaller background-image="images/background2.png" style="font-size:0.6em;"}

```{r}
fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput('valor_num', 'Seleccionar columna', c("prima_emitida","suma_aseg"), selectize=TRUE)
    ),
    mainPanel(
      textOutput("pvalor"),
      tableOutput("viewTable2"),
      plotOutput("viewGrafico3")
      
    )
  )
)
```

```{r}
#| context: server

library(readxl)  # Para leer archivos Excel
library(dplyr)   # Para manipulación de datos
library(ggplot2) # Para visualización de datos
library(tidyr)   # Para manipular la estructura de los datos
library(knitr) 
library(DT)
library(rlang)
pregunta2 <- function(datos, relacion1, relacion2, numerico1){
  # Convert column names from string to symbols
  relacion1_sym <- sym(relacion1)
  relacion2_sym <- sym(relacion2)
  numerico1_sym <- sym(numerico1)
  
  # Group and summarize to calculate the total
  tabla_conti <- datos %>%
    group_by(!!relacion1_sym, !!relacion2_sym) %>%
    summarise(total_numerico1 = sum(!!numerico1_sym, na.rm = TRUE), .groups = 'drop')
  
  # Create contingency matrix
  matriz_contingencia <- xtabs(total_numerico1 ~ ., data = tabla_conti)
  
  # Convert the matrix to a data frame immediately to maintain data frame structure
  matriz_contingencia_df <- as.data.frame.matrix(matriz_contingencia)
  matriz_contingencia_df <- cbind(Indice = rownames(matriz_contingencia_df), matriz_contingencia_df)
  
  # Perform chi-squared test
  prueba_chi <- chisq.test(matriz_contingencia)
  result1 <- prueba_chi$p.value
  
  # Calculate residuals
  residuos <- residuals(prueba_chi, type = "pearson")
  residuos <- as.data.frame(residuos)
  residuos
  
  # Create graph
  grafica <- ggplot(tabla_conti, aes(x = !!relacion1_sym, y = total_numerico1, fill = !!relacion2_sym)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    theme_minimal() +
    labs(title = "Numerico1 Promedio por Relacion1 y Relacion2",
         x = relacion1,
         y = "Numerico1 Promedio") +
    theme(legend.position = "bottom")
  
  # Return results as a list
  resultado <- list(Contigencia = matriz_contingencia_df,  # Return as a data frame
                    Valorp = result1,
                    Residuos = residuos,
                    Diagrama = grafica)
  
  return(resultado)
}

seleccion <- reactive({
  input$valor_num
})

data3 <- reactive({
  pregunta2(data(), "sucursal", "ramo_comercial", seleccion())[1]
})

data4 <- reactive({
  pregunta2(data(), "sucursal", "ramo_comercial", seleccion())[3]
})

diagrama <- reactive({
  pregunta2(data(), "sucursal", "ramo_comercial", seleccion())[4]
})

pvalor_ <- reactive({
  paste('Test Chi-Cuadrado, Pvalor: ',as.character(pregunta2(data(), "sucursal", "ramo_comercial", "prima_emitida")[2]))
})

output$pvalor <-renderText({
  pvalor_()
})

output$viewGrafico3 <- renderPlot(
  diagrama()
)

output$viewTable2 <- renderTable(
  head(data3()), width = "100%"
)

output$viewTable3 <- renderTable({
  data4()
})
```

### Residuos de Pearson

```{r}
tableOutput("viewTable3")
```
:::

## Serie Temporal {.smaller background-image="images/background2.png"}
